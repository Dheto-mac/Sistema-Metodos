void gauss2x2(double **mat)
{
	int i,j;
	double x,y,aux;
	

    aux=(*(*(mat+1)+0) / *(*(mat+0)+0))*(-1);
    for(i=0;i<3;i++)
 	  (*(*(mat+1)+i)) =(aux * (*(*(mat+0)+i)))+ *(*(mat+1)+i);
 	  
 	if(*(*(mat+0)+0)==0&& *(*(mat+0)+1)==0||*(*(mat+1)+0)==0&& *(*(mat+1)+1)==0)
 	 {
 	   cout<<"infinitas soluciones";
 	   exit(1);
     }
	   
	  y=(*(*(mat+1)+2))/ (*(*(mat+1)+1)); 
	  x=((*(*(mat+0)+2))-((*(*(mat+0)+1))*y)) / (*(*(mat+0)+0));
 	   

	
}
void gauss3x3(double **mat)
{

	  int i,j;
    double x,y,z,aux;

    if((*(*(mat+0)+0)== 0) || (*(*(mat+0)+0)==0 && *(*(mat+1)+1)==0 && *(*(mat+2)+2)==0))
    {
       cout<<"El sistema no tiene solucion por el metodo de Gauss\n";
       exit(1);
    }
     
    aux=(*(*(mat+1)+0)/ *(*(mat+0)+0))*(-1);
    for(i=0;i<4;i++)
 	  (*(*(mat+1)+i)) = (aux* (*(*(mat+0)+i)))+ (*(*(mat+1)+i)); 
 	
    aux=(*(*(mat+2)+0)/ (*(*(mat+0)+0)))*(-1);
    for( i=0;i<4;i++)
 	   (*(*(mat+2)+i)) =(aux* (*(*(mat+0)+i)))+ *(*(mat+2)+i);
 	
    aux=((*(*(mat+2)+1))/ (*(*(mat+1)+1)))*(-1);
    for( i=0;i<4;i++)
 	   (*(*(mat+2)+i)) =(aux* (*(*(mat+1)+i)))+ (*(*(mat+2)+i));
 	   	
	if(*(*(mat+0)+0)==0&&(*(*(mat+0)+1))==0&&(*(*(mat+0)+2))==0||
	   (*(*(mat+1)+0))==0&&(*(*(mat+1)+1))==0&&(*(*(mat+1)+2))==0||
	  (*(*(mat+2)+0))==0&&(*(*(mat+2)+1))==0&&(*(*(mat+2)+2))==0)
 	  {
 	   cout<<"infinitas soluciones";
 	   exit(1);
      }
 	   
 	z=(*(*(mat+2)+3)) / (*(*(mat+2)+2));
 	y=((*(*(mat+1)+2))-(((*(*(mat+1)+2))*z)))/ (*(*(mat+1)+1));
 	x=((*(*(mat+0)+3))-((*(*(mat+0)+1))*y)-(((*(*(mat+0)+2))*z)))/ (*(*(mat+0)+0));
 	
	
}
void gaussjordan2x2(double **mat)
{
	int i,j;
	double x,y,aux;
	
    aux=((*(*(mat+1)+0))/ (*(*(mat+0)+0)))*(-1);
    for(i=0;i<3;i++)
 	  (*(*(mat+1)+i)) =(aux* (*(*(mat+0)+i)))+(*(*(mat+1)+i));
 	
	 if((*(*(mat+0)+0))==0&&(*(*(mat+0)+1))==0||(*(*(mat+1)+0))==0&&((*(*(mat+1)+1)))==0)
 	 {
 	   cout<<"infinitas soluciones";
 	   exit(1);
     }
 	  
 	aux=(((*(*(mat+0)+1)))/(*(*(mat+1)+1)))*(-1);
    for( i=0;i<4;i++)
 	  (*(*(mat+0)+i)) =(aux*(*(*(mat+1)+i)))+(*(*(mat+0)+i));
 	   
 	 if((*(*(mat+0)+0))==0&&(*(*(mat+0)+1))==0||(*(*(mat+1)+0))==0&&(*(*(mat+1)+1))==0)
 	 {
 	   cout<<"infinitas soluciones";
 	   exit(1);
     }
 	  


	  x= (*(*(mat+0)+2))/ (*(*(mat+0)+0));
	  y= (*(*(mat+1)+2))/(*(*(mat+1)+1));
	  

}
void gaussjordan3x3(double **mat)
{
		int i,j;
    double x,y,z,aux,aux2;

    if(((*(*(mat+0)+0))== 0) || ((*(*(mat+0)+0))==0 && (*(*(mat+1)+1))==0 && (*(*(mat+2)+2))==0))
    {
       cout<<"El sistema no tiene solucion por el metodo de Gauss\n";
       exit(1);
    }
     
    aux=((*(*(mat+1)+0))/(*(*(mat+0)+0)))*(-1);
    for(i=0;i<4;i++)
 	  (*(*(mat+1)+i)) =(aux*(*(*(mat+0)+i)))+(*(*(mat+1)+i)); 
 	
    aux=((*(*(mat+2)+0))/(*(*(mat+0)+0)))*(-1);
    for( i=0;i<4;i++)
 	   (*(*(mat+2)+i)) =(aux*(*(*(mat+0)+i)))+(*(*(mat+2)+i));
 	
    aux=((*(*(mat+0)+1))/(*(*(mat+1)+1)))*(-1);
    for( i=0;i<4;i++)
 	   (*(*(mat+0)+i)) =(aux*(*(*(mat+1)+i)))+(*(*(mat+0)+i));

 	aux=((*(*(mat+2)+1))/(*(*(mat+1)+1)))*(-1);
 	for( i=0;i<4;i++)
 	   (*(*(mat+2)+i)) =(aux*(*(*(mat+1)+i)))+(*(*(mat+2)+i));
 	   
 	aux=((*(*(mat+0)+2))/(*(*(mat+2)+2)))*(-1);
 	for( i=0;i<4;i++)
 	   (*(*(mat+0)+i)) =(aux*(*(*(mat+2)+i)))+(*(*(mat+0)+i));
 	   
 	aux=((*(*(mat+1)+2))/(*(*(mat+2)+2)))*(-1);
 	for( i=0;i<4;i++)
 	   (*(*(mat+1)+i)) =(aux*(*(*(mat+2)+i)))+(*(*(mat+1)+i));
 	   
 	if((*(*(mat+0)+0))==0&&(*(*(mat+0)+1))==0&&(*(*(mat+0)+2))==0||
	   (*(*(mat+1)+0))==0&&(*(*(mat+1)+1))==0&&(*(*(mat+1)+2))==0||
	   (*(*(mat+2)+0))==0&&(*(*(mat+2)+1))==0&&(*(*(mat+2)+2))==0)
 	  {
 	   cout<<"infinitas soluciones";
 	   exit(1);
      }
 	x= (*(*(mat+0)+3))/(*(*(mat+0)+0));
 	y= (*(*(mat+1)+3))/(*(*(mat+1)+1));
 	z= (*(*(mat+2)+3))/(*(*(mat+2)+2));  
 	
 	   
}
void jacobi3x3(double **mat)
{
	int n=9,i,j; // n es el numero de veces que hara el proceso para ver la convergencia
	double x[n],y[n],z[n],aux[3][3],aux2;
	 //pone a toda la matriz en valor absoluto
	for(i=0;i<3;i++)  
	{
		for(j=0;j<3;j++)
		{
			if((*(*(mat+i)+j))>0)
			 aux[i][j]=(*(*(mat+i)+j));
			else
			 aux[i][j]=(*(*(mat+i)+j))*(-1);
			
		}
	}
	//valida que sea diagonalmente dominante
	if(aux2=aux[0][1]+aux[0][2]>aux[0][0]) 
	{
		cout<<"No es diagonalmente dominante por lo tanto no se garantiza la convergencia"<<endl;
	}
	else
	  if(aux2=aux[1][0]+aux[1][2]>aux[1][1])
	  {
	  		cout<<"No es diagonalmente dominante por lo tanto no se garantiza la convergencia"<<endl;
	  }
	  else
	    if(aux2=aux[2][0]+aux[2][1]>aux[2][2])
	    {
	    		cout<<"No es diagonalmente dominante por lo tanto no se garantiza la convergencia"<<endl;
		}
	
	x[0]=(*(*(mat+0)+3))/(*(*(mat+0)+0));
	y[0]=(*(*(mat+1)+3))/(*(*(mat+1)+1)); 
	z[0]=(*(*(mat+2)+3))/(*(*(mat+2)+2));
	
	for(i=0;i<n;i++)
	{
	  x[i+1]=((*(*(mat+0)+3))-(*(*(mat+0)+1))*y[i]-(*(*(mat+0)+2))*z[i])/(*(*(mat+0)+0));
	  y[i+1]=((*(*(mat+1)+3))-(*(*(mat+1)+0))*x[i]-(*(*(mat+1)+2))*z[i])/(*(*(mat+1)+1));
	  z[i+1]=((*(*(mat+2)+3))-(*(*(mat+2)+0))*x[i]-(*(*(mat+2)+1))*y[i])/(*(*(mat+2)+2));	
	} 
	
}
void seidel3x3(double **mat)
{
	int n=15,i,j;// n es el numero de veces que hara el proceso para ver la convergencia
	double x[n],y[n],z[n],aux[3][3],aux2;
	 //pone a toda la matriz en valor absoluto
	for(i=0;i<3;i++) 
	{
		for(j=0;j<3;j++)
		{
			if((*(*(mat+i)+j))>0)
			 aux[i][j]=(*(*(mat+i)+j));
			else
			 aux[i][j]=(*(*(mat+i)+j))*(-1);
			
		}
	}
	//valida que sea diagonalmente dominante
	if(aux2=aux[0][1]+aux[0][2]>aux[0][0])
	{
		cout<<"No es diagonalmente dominante por lo tanto no se garantiza la convergencia"<<endl;
	}
	else
	  if(aux2=aux[1][0]+aux[1][2]>aux[1][1])
	  {
	  		cout<<"No es diagonalmente dominante por lo tanto no se garantiza la convergencia"<<endl;
	  }
	  else
	    if(aux2=aux[2][0]+aux[2][1]>aux[2][2])
	    {
	    		cout<<"No es diagonalmente dominante por lo tanto no se garantiza la convergencia"<<endl;
		}
	
	x[0]=(*(*(mat+0)+3))/(*(*(mat+0)+0));
	y[0]=((*(*(mat+1)+3))-(*(*(mat+1)+0))*x[0]/(*(*(mat+1)+1))); 
	z[0]=((*(*(mat+2)+3))-(*(*(mat+2)+0))*x[0]-(*(*(mat+2)+1))*y[0])/(*(*(mat+2)+2));
	
	for(i=0;i<n;i++)
	{
	  x[i+1]=((*(*(mat+0)+3))-(*(*(mat+0)+1))*y[i]-(*(*(mat+0)+2))*z[i])/(*(*(mat+0)+0));
	  y[i+1]=((*(*(mat+1)+3))-(*(*(mat+1)+0))*x[i+1]-(*(*(mat+1)+2))*z[i])/(*(*(mat+1)+1));
	  z[i+1]=((*(*(mat+2)+3))-(*(*(mat+2)+0))*x[i+1]-(*(*(mat+2)+1))*y[i+1])/(*(*(mat+2)+2));	
	} 
	
}
